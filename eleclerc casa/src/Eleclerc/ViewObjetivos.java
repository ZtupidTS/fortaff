/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Eleclerc;

import Configuration.configurationJframe;
import Db.DbData;
import Type.Family;
import Type.Vendas;
import Utils.*;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTable;

/**
 *
 * @author ricardo
 */
public class ViewObjetivos extends javax.swing.JFrame {

    private ArrayList<Family> arFam = new ArrayList<>();
    private JTable jtable;
    private int type;
    
    /**
     * Creates new form ViewObjetivos
     * type:
     * 0 : vendas
     * 1 : quebras
     */
    public ViewObjetivos(int type) {
        initComponents();
        this.type = type;
        jDateChooserDay.setDate(new Date());
        this.setTitle("Ver Objetivos");
        try {
            configurationJframe.inicialConfiguration(this);
        } catch (SQLException ex) {
            //Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
            Messages.messageErrorDb("MainJFrame : inicialização jframe");
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabelday = new javax.swing.JLabel();
        jDateChooserDay = new com.toedter.calendar.JDateChooser();
        jButtonOk = new javax.swing.JButton();
        jButtonClose = new javax.swing.JButton();
        jScrollPaneObj = new javax.swing.JScrollPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);

        jLabelday.setText("Dia");

        jButtonOk.setText("Ok");
        jButtonOk.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonOkActionPerformed(evt);
            }
        });

        jButtonClose.setText("Fechar");
        jButtonClose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCloseActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPaneObj)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabelday)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jDateChooserDay, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(30, 30, 30)
                        .addComponent(jButtonOk)
                        .addGap(18, 18, 18)
                        .addComponent(jButtonClose)
                        .addGap(0, 305, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jButtonOk)
                        .addComponent(jButtonClose))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(jDateChooserDay, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabelday)))
                .addGap(18, 18, 18)
                .addComponent(jScrollPaneObj, javax.swing.GroupLayout.DEFAULT_SIZE, 518, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonCloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCloseActionPerformed
        this.dispose();
    }//GEN-LAST:event_jButtonCloseActionPerformed

    private void jButtonOkActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonOkActionPerformed
        if (jDateChooserDay.getDate() != null)
        {
            switch(type)
            {
                case 0:
                    objVendas();
                    break;
                case 1:
                    objQuebras();
                    break;
            }
            //ajusto das colunas da jtable
            int[] columnadj = { 0, 1 };
            int[] width = { 60, 200};
            jScrollPaneObj.setViewportView(new UtilsTable().adjustColumn(jtable, columnadj, width));            
        }else{
            Messages.messageInformation("Tem de seleccionar uma data", "Aviso");
        }
    }//GEN-LAST:event_jButtonOkActionPerformed

    private void objQuebras()
    {
        try {
            //minha array que vai conter objectos do tipo familia
            arFam.clear();
            arFam = new UtilsJframe().arSubSection();
            //hashmap que vai conter os objetivos pretendidos do mês
            HashMap arObjqMonth = new HashMap();
            ResultSet rsObjqMonth = (ResultSet) DbData.getDataTable("objetivos_quebras", "YEAR(objq_date) = '"+
                    UtilsDate.getYear(jDateChooserDay.getDate())+"' AND MONTH(objq_date) = '"+
                    UtilsDate.getMonth(jDateChooserDay.getDate()) +"' AND objq_type = 'M' AND "+
                    new UtilsDb().getWhereSubsection("objq_fam_id"),
                    "", "objq_fam_id", true);
            while(rsObjqMonth.next())
            {
                //arObjMonth.add(rsObjMonth.getDouble("obj_value"));
                arObjqMonth.put(rsObjqMonth.getInt("objq_fam_id"), rsObjqMonth.getDouble("objq_value"));
            }
            //hashmap das vendas do mês
            HashMap sellMonth = new HashMap();
            String [] where2 = {"YEAR(ve_date)", 
                Utils.convertIntegerToString(UtilsDate.getYear(jDateChooserDay.getDate())),
                "MONTH(ve_date)", Utils.convertIntegerToString(UtilsDate.getMonth(jDateChooserDay.getDate())),
                new UtilsDb().getWhereSubsection("ve_fam_id")};
            String[] column2 = { "ve_valor", "ve_fam_id" };
            ResultSet rsSellYearMonth = (ResultSet) DbData.getSumColunaMore("vendas", where2, column2, "ve_fam_id", "ve_fam_id");
            while(rsSellYearMonth.next())
            {
                sellMonth.put(rsSellYearMonth.getInt("ve_fam_id"), rsSellYearMonth.getDouble("ve_valor"));
            }
            //hashmap das quebras desse mês
            HashMap quebrasMonth = new HashMap();
            String [] whereQue = {"YEAR(que_date)", 
                Utils.convertIntegerToString(UtilsDate.getYear(jDateChooserDay.getDate())),
                "MONTH(que_date)", Utils.convertIntegerToString(UtilsDate.getMonth(jDateChooserDay.getDate())),
                new UtilsDb().getWhereSubsection("que_fam_id")};
            String[] columnQue = { "que_valor", "que_fam_id" };
            ResultSet rsQueMonth = (ResultSet) DbData.getSumColunaMore("quebras", whereQue, columnQue, "que_fam_id", "que_fam_id");
            while(rsQueMonth.next())
            {
                quebrasMonth.put(rsQueMonth.getInt("que_fam_id"), rsQueMonth.getDouble("que_valor"));
            }
            HashMap finalValorQuebras = diffquebrasHashMap(sellMonth, quebrasMonth);
            
            Object[][] donnees = new Object[arFam.size()][4];
            for(int i=0;i<arFam.size();i++)
            {
                Family fam = arFam.get(i);
                donnees[i][0] = fam.getFamId();
                donnees[i][1] = fam.getFamDescription();
                if(finalValorQuebras.containsKey(fam.getFamId()))
                {
                    donnees[i][2] = finalValorQuebras.get(fam.getFamId());
                }else{
                    donnees[i][2] = new Double(0.00);
                }
                if(arObjqMonth.containsKey(fam.getFamId()))
                {
                    donnees[i][3] = arObjqMonth.get(fam.getFamId());
                }else{
                    donnees[i][3] = new Double(0.00);
                }
            } 
            //cabeçalho tabela
            String[] entetes = new String[4];
            entetes[0] = " ";
            entetes[1] = " ";
            entetes[2] = "Realizado Mês";
            entetes[3] = "Pretendido";
            
            jtable = new UtilsTable().FillJTable(donnees, entetes, 99, 3);
            
        } catch (SQLException ex) {
            //Logger.getLogger(ViewObjetivos.class.getName()).log(Level.SEVERE, null, ex);
            Messages.messageErrorDb("ViewObjectivos : botão ok");
        }        
    }
    
    private void objVendas()
    {
        try {
            //minha array que vai conter objectos do tipo familia
            arFam.clear();
            arFam = new UtilsJframe().arSubSection();

//                //Arraylist que vai conter os objetivos do dia
//                ArrayList<Double> arObjDay = new ArrayList<>();
//                ResultSet rsObjDay = (ResultSet) DbData.getDataTable("objetivos", "obj_date = '"+
//                        UtilsDate.dateToStringMysql(jDateChooserDay.getDate())+"' and obj_type = 'D' AND "+
//                        new UtilsDb().getWhereSubsection("obj_fam_id"), ""
//                        , "obj_fam_id", true);
//                while(rsObjDay.next())
//                {
//                    arObjDay.add(rsObjDay.getDouble("obj_value"));
//                }
//
            //ArrayList que vai conter os objetivos do mês
            HashMap arObjMonth = new HashMap();
            ResultSet rsObjMonth = (ResultSet) DbData.getDataTable("objetivos", "YEAR(obj_date) = '"+
                    UtilsDate.getYear(jDateChooserDay.getDate())+"' AND MONTH(obj_date) = '"+
                    UtilsDate.getMonth(jDateChooserDay.getDate()) +"' AND obj_type = 'M' AND "+
                    new UtilsDb().getWhereSubsection("obj_fam_id"),
                    "", "obj_fam_id", true);
            while(rsObjMonth.next())
            {
                //arObjMonth.add(rsObjMonth.getDouble("obj_value"));
                arObjMonth.put(rsObjMonth.getInt("obj_fam_id"), rsObjMonth.getDouble("obj_value"));
            }
//
//                //HashMap do objetivo atingido dia
//                
//                // primeiro vou buscar as vendas do ano anterior
//                ArrayList<Vendas> sellYearOld = new ArrayList<>();
//                ResultSet rsSellYearOld = (ResultSet) DbData.getDataTable("vendas", "YEAR(ve_date) = '"+
//                        (UtilsDate.getYear(jDateChooserDay.getDate())-1)+"' AND MONTH(ve_date) = '"+
//                        UtilsDate.getMonth(jDateChooserDay.getDate())+"' AND DAY(ve_date) = '"+
//                        UtilsDate.getDay(jDateChooserDay.getDate())+"' AND "+
//                        new UtilsDb().getWhereSubsection("ve_fam_id"),
//                        "", "ve_fam_id", true);
//                while(rsSellYearOld.next())
//                {
//                    sellYearOld.add(new Vendas(rsSellYearOld.getInt("ve_id"),
//                            rsSellYearOld.getInt("ve_fam_id"), rsSellYearOld.getDouble("ve_valor"),
//                            rsSellYearOld.getDate("ve_date")));
//                }
//                //Agora vendas desse ano
//                ArrayList<Vendas> sellYear = new ArrayList<>();
//                ResultSet rsSellYear = (ResultSet) DbData.getDataTable("vendas", "YEAR(ve_date) = '"+
//                        UtilsDate.getYear(jDateChooserDay.getDate())+"' AND MONTH(ve_date) = '"+
//                        UtilsDate.getMonth(jDateChooserDay.getDate())+"' AND DAY(ve_date) = '"+
//                        UtilsDate.getDay(jDateChooserDay.getDate())+"' AND "+
//                        new UtilsDb().getWhereSubsection("ve_fam_id"),
//                        "", "ve_fam_id", true);
//                while(rsSellYear.next())
//                {
//                    sellYear.add(new Vendas(rsSellYear.getInt("ve_id"),
//                            rsSellYear.getInt("ve_fam_id"), rsSellYear.getDouble("ve_valor"),
//                            rsSellYear.getDate("ve_date")));
//                }
//                //Vou comparar as vendas e vi me devolver um array do da diferença
//                HashMap finalDayValue = CompareSell(sellYearOld, sellYear);

            //HashMap do objetivo atingido mês
            // primeiro vou buscar as vendas do ano anterior
            HashMap sellYearMonthOld = new HashMap();
            String [] where = {"YEAR(ve_date)", 
                Utils.convertIntegerToString(UtilsDate.getYear(jDateChooserDay.getDate())-1),
                "MONTH(ve_date)", Utils.convertIntegerToString(UtilsDate.getMonth(jDateChooserDay.getDate())),
                new UtilsDb().getWhereSubsection("ve_fam_id")
            };
            String[] column = { "ve_valor", "ve_fam_id" };
            ResultSet rsSellYearMonthOld = (ResultSet) DbData.getSumColunaMore("vendas", where, column, "ve_fam_id", "ve_fam_id");
            while(rsSellYearMonthOld.next())
            {
                sellYearMonthOld.put(rsSellYearMonthOld.getInt("ve_fam_id"), rsSellYearMonthOld.getDouble("ve_valor"));
            }
            //Agora vendas desse ano
            HashMap sellYearMonth = new HashMap();
            String [] where2 = {"YEAR(ve_date)", 
                Utils.convertIntegerToString(UtilsDate.getYear(jDateChooserDay.getDate())),
                "MONTH(ve_date)", Utils.convertIntegerToString(UtilsDate.getMonth(jDateChooserDay.getDate())),
                new UtilsDb().getWhereSubsection("ve_fam_id")
            };
            String[] column2 = { "ve_valor", "ve_fam_id" };
            ResultSet rsSellYearMonth = (ResultSet) DbData.getSumColunaMore("vendas", where2, column2, "ve_fam_id", "ve_fam_id");
            while(rsSellYearMonth.next())
            {
                sellYearMonth.put(rsSellYearMonth.getInt("ve_fam_id"), rsSellYearMonth.getDouble("ve_valor"));
            }
            //Vou comparar as vendas e vai me devolver um hashmap da diferença
            HashMap finalMonthValue = compareSellHashMap(sellYearMonth, sellYearMonthOld);

            Object[][] donnees = new Object[arFam.size()][4];
//                if(arObjDay.size() == arObjMonth.size())
//                {
//                    if(arFam.size() == arObjDay.size())
//                    {
                    for(int i=0;i<arFam.size();i++)
                    {
                        Family fam = arFam.get(i);
                        donnees[i][0] = fam.getFamId();
                        donnees[i][1] = fam.getFamDescription();
//                            if(finalDayValue.containsKey(fam.getFamId()))
//                            {
//                                donnees[i][2] = finalDayValue.get(fam.getFamId());
//                            }else{
//                                donnees[i][2] = new Double(0.00);
//                            }
//                            donnees[i][3] = arObjDay.get(i);
                        if(finalMonthValue.containsKey(fam.getFamId()))
                        {
                            donnees[i][2] = finalMonthValue.get(fam.getFamId());
                        }else{
                            donnees[i][2] = new Double(0.00);
                        }
                        if(arObjMonth.containsKey(fam.getFamId()))
                        {
                            donnees[i][3] = arObjMonth.get(fam.getFamId());
                        }else{
                            donnees[i][3] = new Double(0.00);
                        }
                    }                        
//                    }else{
//                        Messages.messageInformation("Existe um problema, chamar o administrador", "Informação");
//                    }
//                }else{
//                    Messages.messageInformation("Os objetivos não foram preenchidos", "Informação");
//                }
            //cabeçalho tabela
            String[] entetes = new String[4];
            entetes[0] = " ";
            entetes[1] = " ";
//                entetes[2] = "Realizado Dia";
//                entetes[3] = "Pretendido";
            entetes[2] = "Realizado Mês";
            entetes[3] = "Pretendido";

            jtable = new UtilsTable().FillJTable(donnees, entetes, 99, 2);
            

        } catch (SQLException ex) {
            //Logger.getLogger(ViewObjetivos.class.getName()).log(Level.SEVERE, null, ex);
            Messages.messageErrorDb("ViewObjectivos : botão ok");
        }
    }
//    private HashMap CompareSell(ArrayList<Vendas> arold, ArrayList<Vendas> arnew)
//    {
//        HashMap objvendas = new HashMap();
//        ArrayList<Vendas> arLess;
//        if(arold.size() != arnew.size())
//        {
//            if(arold.size() > arnew.size())
//            {
//                arLess = arnew;
//            }else{
//                arLess = arold;
//            }
//        }else{
//            arLess = arnew;
//        }
//        for(int i=0;i<arLess.size();i++)
//        {
//            Vendas vold = arold.get(i);
//            Vendas vnew = arnew.get(i);
//            Family fam = arFam.get(i);
//            if(fam.getFamId() == vold.getFamId() && fam.getFamId() == vnew.getFamId())
//            {
//                Double valuefinal = ((vnew.getValor() - vold.getValor())/vold.getValor())*100;
//                objvendas.put(fam.getFamId(), valuefinal);
//            }else{
//                int j = 1;
//                boolean stop = false;
//                while(fam.getFamId() == vold.getFamId())
//                {
//                    if((i+j) < arold.size())
//                    {
//                        vold = arold.get(i+j);
//                        j++;
//                    }else{
//                        stop = true;
//                    }
//                    if(stop)
//                        break;
//                }
//                j = 1;
//                stop = false;
//                while(fam.getFamId() == vnew.getFamId())
//                {
//                    if((i+j) < arnew.size())
//                    {
//                        vnew = arnew.get(i+j);
//                        j++;
//                    }else{
//                        stop = true;
//                    }
//                    if(stop)
//                        break;
//                }
//                if(stop)
//                {
//                   objvendas.put(fam.getFamId(), new Double(0.00)); 
//                }else{
//                    Double valuefinal = ((vnew.getValor() - vold.getValor())/vold.getValor())*100;
//                    objvendas.put(fam.getFamId(), valuefinal);
//                }
//            }
//        }
//        return objvendas;
//    }
    
    private HashMap compareSellHashMap(HashMap hnew, HashMap hold)
    {
        HashMap objvendas = new HashMap();
        for(int i=0;i<arFam.size();i++)
        {
            Family fam = arFam.get(i);
            if(hnew.containsKey(fam.getFamId()) && hold.containsKey(fam.getFamId()))
            {
                Double valuefinal = (((Double)hnew.get(fam.getFamId()) - (Double)hold.get(fam.getFamId()))/(Double)hold.get(fam.getFamId()))*100;
                objvendas.put(fam.getFamId(), Utils.nummberDecimalDouble(valuefinal, 2));
            }else{
                objvendas.put(fam.getFamId(), new Double(0.00));
            }
        }
        return objvendas;
    }
    
    private HashMap diffquebrasHashMap(HashMap hven, HashMap hque)
    {
        HashMap objvendas = new HashMap();
        for(int i=0;i<arFam.size();i++)
        {
            Family fam = arFam.get(i);
            if(hven.containsKey(fam.getFamId()) && hque.containsKey(fam.getFamId()))
            {
                Double valuefinal = (((Double)hque.get(fam.getFamId()) * 100)/(Double)hven.get(fam.getFamId()));
                objvendas.put(fam.getFamId(), Utils.nummberDecimalDouble(valuefinal, 2));
            }else{
                objvendas.put(fam.getFamId(), new Double(0.00));
            }
        }
        return objvendas;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonClose;
    private javax.swing.JButton jButtonOk;
    private com.toedter.calendar.JDateChooser jDateChooserDay;
    private javax.swing.JLabel jLabelday;
    private javax.swing.JScrollPane jScrollPaneObj;
    // End of variables declaration//GEN-END:variables
}
